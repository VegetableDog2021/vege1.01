参考教材6.1，结合自己项目的实际开发，分析采用了哪种设计方法。
自顶向下，从整体分析一个比较复杂的大问题。为了解决这一问题，必须把它拆分来看，应当解决哪几个小问题，然后再逐步细分到更小的问题。解决了所有的小问题，逐步向上汇总，就完成了最初的复杂问题。
自底向上：先描述，后编程。当面对一个复杂的大问题时，首先把它泛化为一大类问题，用一些基本概念对所有这些问题进行描述。然后逐步增加那些必不可少的概念，直到我们能够完整而细致地把这些问题描绘清楚。  
我们的项目应当是采用了自顶向下结合从外到内的方法，从以下几个步骤开始：  
（1）分析技术环境需要  
（2）分析输入和输出数据，根据功能需求划分模块，进行模块化设计。  
（3）明确软件总体的功能和结构  
  
  
参考教材6.2，结合项目的进程和开发历程，从设计原则的几个方面，组员对负责设计的模块进行评估，写出存在的问题和解决方案思考。  
模块化  
也称作关注点分离 , 是一种把系统中各不相关的部分进行分离的原则,以便于各部分能够独立研究。关注点可以是功能、数据、特征、任务、性质或者我们想要定义或详细理解的需求以及设计的任何部分。为了实现模块化设计，我们通过辨析系统不相关的关注点来分解系统，并且把它们放置于各自的模块中。如果该原则运用得当，每个模块都有自己的唯一目的，并且相对独立于其他模块。使用这种方法，每个模块理解和开发将会更加简单。同时，模块独立也将使得故障的定位和系统的修改更加简单（因为对于每一个故障，可疑的模块会减少，且一个模块的变动所影响的其他模块会减少)。
度量模块的独立程度:耦合度和内聚度。  
1. 耦合度  
当两个模块之间有大量依赖关系时，我们就说这两个模块是紧密耦合的(tighly coupled)。松散耦合的（loosely coupled）模块之间具有某种程度的依赖性，但是它们之间的相互连接比较弱。非耦合的(uncoupled）模块之间没有任何相互连接，它们之间是完全独立的。
2. 内聚度  
内聚度是指模块的内部元素（比如，数据、功能、内部模块）的“粘合”程度。一个模块的内聚度越高，模块内部的各部分之间的相互联系就越紧密，与总体目标就越相关。一个模块如果有多个总体目标，它的元素就会有多种变化方式或变化值。例如，一个模块同时包含了数据和例程，并用以来显示那些数据，这个模块可能会频繁更改且以不同的方式变更，因为每次使用这些数据时都需要使用改变这些值的新功能和显示这些值的新方法。我们的目的是尽可能地使模块高内聚，这样各个模块才能易于理解。   

####存在的问题
目前代码的模块较为混乱，耦合度很高需要修改，内聚度较低，有有一定作用但整体意义不明的代码存在，需要整合功能。  


接口  
  
第4章中，软件系统有一个外部边界和一个对应的接口，通过这个接口软件系统可以感知和控制它的环境。每个软件单元也有一个边界将它和系统的其余部分分开，以及一个接口来和其他软件单元进行交互。接口(interface)为系统其余部分定义了该软件单元提供的服务，以及如何获取这些服务。一个对象的接口是该对象所有公共操作以及这些操作的签名(signature)的集合，指定了操作名称、参数和可能的返回值。接口是这样一种设计结构，它对其他开发人员封装和隐藏了软件单元的设计和实现细节。  
接口是这样一种设计结构，它对其他开发人员封装和隐藏了软件单元的设计和实现细节。
软件单元接口的规格说明(specification）描述了软件单元外部可见的性质。接口的规格说明的描述以单元的边界为依据对软件单元做出描述:该单元的访问函数、参数、返回值和异常。一个接口的规格说明需向其他系统开发人员传达正确应用该软件单元的所有信息，这些信息并不仅仅局限于单元的访问功能和它们的签名，还有如下几点。  
目标:我们为每个访问函数的功能性建立充分详细的文档，以帮助其他开发人员找出最符合他们需要的访问函数。  
前置条件:我们列出所有假设，又称为前置条件（precondition)（如，输入参数的值、全局资源的状态，或者存在哪些程序库及软件单元)，以帮助其他开发人员了解在何种情况下该软件单元才能正确工作。  
协议:协议的信息包括访问函数的调用顺序、两个构件交换信息的模式。比如，一个模块进行调用共享资源之前需要被授权允许。  
后置条件:我们将可见的影响称为后置条件（ postcondition)。我们为每个访问函数的后置条件编写文档，包括返回值、引发的异常以及公共变量(如输出文件）的变化，这样，调用它的代码才能对函数的输出做出适当的反应。    
    
####存在的问题  
目前没有说明文档，但应用较为正常。  
 
  
信息隐藏  
信息隐藏（information hiding)(Parnas 1972)的目标是使得软件系统更加易于维护。它以系统分解为特征:每个软件单元都封装了一个将来可以改变的独立的设计决策，然后我们根据外部可见的性质，在接口和接口规格说明的帮助下描述各个软件单元。因此，这个原则的名称本身也反映了它的结果:单元的设计决策被隐藏了。  
通过遵循信息隐藏原则，--个设计将会被分解成很多小的模块，再者，这些模块可能具有了所有类型的耦合，比如:隐藏了数据表达形式的模块可能是信息内聚的;隐藏了算法的模块可能是功能内聚的
  
####存在的问题 
目前信息隐藏不太好但是可以改进   
  
  
增量式开发
假定一个软件设计是由软件单元和它们的接口所组成的，我们可以使用单元之间的依赖关系来设计出一个增量式设计开发进度表。首先,我们指定单元间的使用关系(uses relation)(Parnas 1978b),它为各个软件单元和它依赖的单元之间建立关联。回顾我们关于耦合的讨论，两个软件单元A和B,它们不彼此调用也可能会互相依赖，例如，单元A依赖单元B构造一个数据结构，并存储在一个独立的单元C中，随后A再访问C。总的说来,如果软件单元A如它接口中描述的那样“需要一个正确的B",才能完成A的任务，那么我们说软件单元A“使用”软件单元B (Parnas 1978b)。因此，倘若只有单元B正确工作才能保证A也能正确工作，则单元A使用单元B。以上的讨论是假设我们能从单元的接口规格说明中得知系统的使用关系，而当接口规格说明不能完整地描述单元间的依赖关系时，我们需要对每个单元的实现计划有充分认识，才能知道它将使用哪些其他单元。  

####存在的问题 
当前并未采用增量式开发，后续可能实现。   
 

抽象  
抽象是一种忽略一些细节来关注其他细节的模型或表示。而在定义中，关于模型中的哪部分细节被忽略是很模糊的，因为不同的目标会对应不同的抽象，会忽略不同的细节。因此，通过回顾我们已经建立起的抽象，理解抽象这个概念将会更加容易。
系统被分解为各个子系统，每个子系统再被分解成更小的子系统，一直分解下去。其中分解的顶层给我们提供了问题系统层次上的纵览，同时对我们隐藏了那些可能会影响我们注意力的细节，有助于我们集中关注我们想要研究和理解的设计功能和特性。当我们观察低一层次的抽象时，我们会发现更多关于各软件单元的细节，它们牵涉到它的主要元素以及这些元素间的关系。各个抽象层次以这种方式隐藏了它的元素如何进一步分解的方法，而每个元素在接口规格说明中将被一一描述，这是另一种关注元素外部行为和避免元素内部设计细节被引用的抽象类型，这些细节将会在分解的下一个层次中显现出来。  

通用性  
通用性(generality)是这样一种设计原则:在开发软件单元时，使它尽可能地能够成为通用的软件，来加强它在将来某个系统中能够被使用的可能性。我们通过增加软件单元使用的上下文环境的数量来开发更加通用的软件单元，下面是几条实现规则。
- 将特定的上下文环境信息参数化:通过把软件单元所操作的数据参数化，我们可以开发出更加通用的软件。  
- 去除前置条件:去除前置条件，使软件在那些我们之前假设不可能发生的条件下工作。
- 简化后置条件:把一个复杂的软件单元分解成若干个具有不同后置条件的单元，再将它们集中起来解决原来需要解决的问题，或者当只需其中一部分后置条件时单独使用。  
  
####存在的问题 
目前仍在开发过程中，各模块比较混沌，通用性较低，后续会进行简化合并。  
 